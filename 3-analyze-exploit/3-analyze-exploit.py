#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Exploit Code Analyzer using LangChain

This tool analyzes exploit code files to:
- Identify the vulnerability type and CVE
- Analyze the attack methodology
- Extract key indicators and payloads
- Assess potential impact and severity
- Provide security recommendations
"""

import os
import sys

# Disable LangSmith tracing to prevent 403 errors
os.environ["LANGCHAIN_TRACING_V2"] = "false"
import argparse
import json
from pathlib import Path
from typing import Dict, List, Optional, Any
from dataclasses import dataclass, asdict
from datetime import datetime

from langchain_core.prompts import ChatPromptTemplate
from langchain_core.output_parsers import JsonOutputParser
from langchain_openai import ChatOpenAI
from pydantic import BaseModel, Field


@dataclass
class ExploitAnalysis:
    """Results of exploit code analysis"""
    file_path: str
    vulnerability_type: str
    cve_id: Optional[str]
    severity: str
    target_software: str
    attack_vector: str
    impact_description: str
    technical_details: Dict[str, Any]
    payloads_identified: List[str]
    indicators_of_compromise: List[str]
    mitigation_recommendations: List[str]
    confidence_score: float
    analysis_timestamp: str


class ExploitAnalysisOutput(BaseModel):
    """Structured output for exploit analysis"""
    vulnerability_type: str = Field(description="Type of vulnerability (e.g., Path Traversal, Buffer Overflow, SQL Injection)")
    cve_id: Optional[str] = Field(description="CVE identifier if available")
    severity: str = Field(description="Severity level: Critical, High, Medium, Low")
    target_software: str = Field(description="Target software and version")
    attack_vector: str = Field(description="How the attack is delivered (Network, Local, Physical)")
    impact_description: str = Field(description="Description of potential impact")
    technical_details: Dict[str, Any] = Field(description="Technical implementation details")
    payloads_identified: List[str] = Field(description="Identified attack payloads")
    indicators_of_compromise: List[str] = Field(description="IOCs that could indicate this exploit")
    mitigation_recommendations: List[str] = Field(description="Security recommendations")
    confidence_score: float = Field(description="Confidence in analysis (0.0-1.0)")


class ExploitAnalyzer:
    """Analyzes exploit code using LangChain and OpenAI"""
    
    def __init__(self, model_name: str = "gpt-4o-mini", temperature: float = 0.1):
        self.llm = ChatOpenAI(
            model=model_name,
            temperature=temperature
        )
        self.parser = JsonOutputParser(pydantic_object=ExploitAnalysisOutput)
        self._setup_analysis_chain()
    
    def _setup_analysis_chain(self):
        """Set up the LangChain analysis chain"""
        
        prompt_template = """
You are a cybersecurity expert analyzing exploit code. Your task is to thoroughly analyze the provided exploit code and extract detailed security information.

EXPLOIT CODE TO ANALYZE:
{exploit_code}

Please analyze this exploit code and provide a comprehensive security assessment. Focus on:

1. **Vulnerability Identification**: What type of vulnerability does this exploit target?
2. **Technical Analysis**: How does the exploit work technically?
3. **Impact Assessment**: What are the potential consequences?
4. **Payload Analysis**: What specific payloads or attack vectors are used?
5. **Detection**: What indicators could help detect this exploit?
6. **Mitigation**: What steps can prevent or mitigate this attack?

Provide your analysis in the following JSON format:
{format_instructions}

Be thorough and precise in your analysis. If any information is unclear or missing, indicate this in your confidence score.
"""
        
        self.prompt = ChatPromptTemplate.from_template(prompt_template)
        self.chain = self.prompt | self.llm | self.parser
    
    def analyze_file(self, file_path: str) -> ExploitAnalysis:
        """Analyze an exploit file and return structured results"""
        
        if not os.path.exists(file_path):
            raise FileNotFoundError(f"Exploit file not found: {file_path}")
        
        # Read the exploit code
        with open(file_path, 'r', encoding='utf-8', errors='ignore') as f:
            exploit_code = f.read()
        
        if not exploit_code.strip():
            raise ValueError(f"Exploit file is empty: {file_path}")
        
        # Run the analysis chain
        try:
            result = self.chain.invoke({
                "exploit_code": exploit_code,
                "format_instructions": self.parser.get_format_instructions()
            })
            
            # Convert to ExploitAnalysis dataclass
            analysis = ExploitAnalysis(
                file_path=file_path,
                vulnerability_type=result.get("vulnerability_type", "Unknown"),
                cve_id=result.get("cve_id"),
                severity=result.get("severity", "Unknown"),
                target_software=result.get("target_software", "Unknown"),
                attack_vector=result.get("attack_vector", "Unknown"),
                impact_description=result.get("impact_description", ""),
                technical_details=result.get("technical_details", {}),
                payloads_identified=result.get("payloads_identified", []),
                indicators_of_compromise=result.get("indicators_of_compromise", []),
                mitigation_recommendations=result.get("mitigation_recommendations", []),
                confidence_score=result.get("confidence_score", 0.0),
                analysis_timestamp=datetime.now().isoformat()
            )
            
            return analysis
            
        except Exception as e:
            raise RuntimeError(f"Analysis failed: {str(e)}")
    
    def analyze_directory(self, directory_path: str, file_extensions: List[str] = None, silent: bool = False) -> List[ExploitAnalysis]:
        """Analyze all exploit files in a directory"""
        
        if file_extensions is None:
            file_extensions = ['.py', '.rb', '.pl', '.sh', '.c', '.cpp', '.java', '.js']
        
        directory = Path(directory_path)
        if not directory.exists():
            raise FileNotFoundError(f"Directory not found: {directory_path}")
        
        results = []
        
        for file_path in directory.rglob("*"):
            if file_path.is_file() and file_path.suffix.lower() in file_extensions:
                try:
                    analysis = self.analyze_file(str(file_path))
                    results.append(analysis)
                    if not silent:
                        print(f"✓ Analyzed: {file_path}")
                except Exception as e:
                    if not silent:
                        print(f"✗ Failed to analyze {file_path}: {e}")
        
        return results


def save_analysis_results(analyses: List[ExploitAnalysis], output_file: str):
    """Save analysis results to a JSON file"""
    
    results_data = {
        "analysis_count": len(analyses),
        "generated_at": datetime.now().isoformat(),
        "analyses": [asdict(analysis) for analysis in analyses]
    }
    
    with open(output_file, 'w', encoding='utf-8') as f:
        json.dump(results_data, f, indent=2, ensure_ascii=False)
    
    print(f"✓ Results saved to: {output_file}")


def print_analysis_summary(analysis: ExploitAnalysis):
    """Print a formatted summary of the analysis"""
    
    print("\n" + "="*80)
    print(f"EXPLOIT ANALYSIS SUMMARY")
    print("="*80)
    print(f"File: {analysis.file_path}")
    print(f"Vulnerability Type: {analysis.vulnerability_type}")
    print(f"CVE ID: {analysis.cve_id or 'Not specified'}")
    print(f"Severity: {analysis.severity}")
    print(f"Target Software: {analysis.target_software}")
    print(f"Attack Vector: {analysis.attack_vector}")
    print(f"Confidence Score: {analysis.confidence_score:.2f}")
    
    print(f"\nImpact Description:")
    print(f"  {analysis.impact_description}")
    
    if analysis.payloads_identified:
        print(f"\nIdentified Payloads:")
        for i, payload in enumerate(analysis.payloads_identified, 1):
            
            print(f"  {i}. {payload}")
    
    if analysis.indicators_of_compromise:
        print(f"\nIndicators of Compromise:")
        for i, ioc in enumerate(analysis.indicators_of_compromise, 1):
            print(f"  {i}. {ioc}")
    
    if analysis.mitigation_recommendations:
        print(f"\nMitigation Recommendations:")
        for i, rec in enumerate(analysis.mitigation_recommendations, 1):
            print(f"  {i}. {rec}")
    
    if analysis.technical_details:
        print(f"\nTechnical Details:")
        for key, value in analysis.technical_details.items():
            print(f"  {key}: {value}")


def main():
    parser = argparse.ArgumentParser(description="Analyze exploit code using LangChain")
    parser.add_argument("target", help="Path to exploit file or directory to analyze")
    parser.add_argument("-o", "--output", help="Output file for JSON results")
    parser.add_argument("--json", action="store_true", help="Output results as JSON to stdout")
    parser.add_argument("-m", "--model", default="gpt-5", help="OpenAI model to use")
    parser.add_argument("-t", "--temperature", type=float, default=0.1, help="Model temperature")
    parser.add_argument("--extensions", nargs="+", default=['.py', '.rb', '.pl', '.sh', '.c', '.cpp'],
                        help="File extensions to analyze (for directory mode)")
    
    args = parser.parse_args()
    
    # Check if OpenAI API key is set
    if not os.getenv("OPENAI_API_KEY"):
        print("Error: OPENAI_API_KEY environment variable is not set")
        sys.exit(1)
    
    # Initialize the analyzer
    try:
        analyzer = ExploitAnalyzer(model_name=args.model, temperature=args.temperature)
    except Exception as e:
        print(f"Error initializing analyzer: {e}")
        sys.exit(1)
    
    # Analyze the target
    target_path = Path(args.target)
    analyses = []
    
    try:
        if target_path.is_file():
            if not args.json:
                print(f"Analyzing single file: {args.target}")
            analysis = analyzer.analyze_file(args.target)
            analyses.append(analysis)
            
            if args.json:
                # Output JSON to stdout
                results_data = {
                    "analysis_count": 1,
                    "generated_at": datetime.now().isoformat(),
                    "analyses": [asdict(analysis)]
                }
                print(json.dumps(results_data, indent=2, ensure_ascii=False))
            else:
                print_analysis_summary(analysis)
            
        elif target_path.is_dir():
            if not args.json:
                print(f"Analyzing directory: {args.target}")
            analyses = analyzer.analyze_directory(args.target, args.extensions, silent=args.json)
            
            if args.json:
                # Output JSON to stdout
                results_data = {
                    "analysis_count": len(analyses),
                    "generated_at": datetime.now().isoformat(),
                    "analyses": [asdict(analysis) for analysis in analyses]
                }
                print(json.dumps(results_data, indent=2, ensure_ascii=False))
            else:
                print(f"\n{'='*80}")
                print(f"DIRECTORY ANALYSIS COMPLETE")
                print(f"{'='*80}")
                print(f"Total files analyzed: {len(analyses)}")
                
                # Print summary for each analysis
                for analysis in analyses:
                    print_analysis_summary(analysis)
        
        else:
            if not args.json:
                print(f"Error: Target path does not exist: {args.target}")
            else:
                error_result = {
                    "error": f"Target path does not exist: {args.target}",
                    "analysis_count": 0,
                    "generated_at": datetime.now().isoformat(),
                    "analyses": []
                }
                print(json.dumps(error_result, indent=2, ensure_ascii=False))
            sys.exit(1)
    
    except Exception as e:
        if not args.json:
            print(f"Error during analysis: {e}")
        else:
            error_result = {
                "error": str(e),
                "analysis_count": 0,
                "generated_at": datetime.now().isoformat(),
                "analyses": []
            }
            print(json.dumps(error_result, indent=2, ensure_ascii=False))
        sys.exit(1)
    
    # Save results if output file specified (only if not using --json for stdout)
    if args.output and analyses and not args.json:
        try:
            save_analysis_results(analyses, args.output)
        except Exception as e:
            print(f"Error saving results: {e}")
    elif args.output and args.json:
        print(f"Warning: --output ignored when using --json flag", file=sys.stderr)


if __name__ == "__main__":
    main()
